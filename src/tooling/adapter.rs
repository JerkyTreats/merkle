//! Agent Adapter
//!
//! Trait for internal agent integration, providing a simplified interface
//! for agents to interact with the context engine.

use crate::api::{ContextApi, ContextView, NodeContext};
use crate::error::ApiError;
use crate::frame::Frame;
use crate::frame::queue::{FrameGenerationQueue, Priority};
use crate::types::{FrameID, NodeID};
use async_trait::async_trait;
use std::sync::Arc;
use std::time::Duration;


/// Adapter for internal agents to interact with the context engine
///
/// Provides a simplified interface for agents to read and write context,
/// synthesize frames, and optionally generate frames using LLM providers.
#[async_trait]
pub trait AgentAdapter: Send + Sync {
    /// Read context for a node using a view policy
    fn read_context(
        &self,
        node_id: NodeID,
        view: ContextView,
    ) -> Result<NodeContext, ApiError>;

    /// Write a context frame to a node
    fn write_context(
        &self,
        node_id: NodeID,
        frame: Frame,
        agent_id: String,
    ) -> Result<FrameID, ApiError>;

    /// Synthesize branch context for a directory node
    fn synthesize(
        &self,
        node_id: NodeID,
        frame_type: String,
        agent_id: String,
    ) -> Result<FrameID, ApiError>;

    /// Generate a frame using an LLM provider (optional)
    ///
    /// This method is async because it may make network requests to LLM providers.
    /// If the agent doesn't have a provider configured, this will return an error.
    async fn generate_frame(
        &self,
        node_id: NodeID,
        prompt: String,
        frame_type: String,
        agent_id: String,
    ) -> Result<FrameID, ApiError>;
}

/// Implementation of AgentAdapter for ContextApi
pub struct ContextApiAdapter {
    api: Arc<ContextApi>,
    /// Optional queue for generation requests (if None, generation will fail)
    queue: Option<Arc<FrameGenerationQueue>>,
}

impl ContextApiAdapter {
    /// Create a new adapter wrapping a ContextApi (without queue - generation will fail)
    pub fn new(api: ContextApi) -> Self {
        Self { 
            api: Arc::new(api),
            queue: None,
        }
    }

    /// Create a new adapter from an Arc<ContextApi> (without queue - generation will fail)
    pub fn from_arc(api: Arc<ContextApi>) -> Self {
        Self { 
            api,
            queue: None,
        }
    }

    /// Create a new adapter with a queue
    pub fn with_queue(api: Arc<ContextApi>, queue: Arc<FrameGenerationQueue>) -> Self {
        Self {
            api,
            queue: Some(queue),
        }
    }

    /// Get a reference to the underlying API
    pub fn api(&self) -> &ContextApi {
        &self.api
    }
}

#[async_trait]
impl AgentAdapter for ContextApiAdapter {
    fn read_context(
        &self,
        node_id: NodeID,
        view: ContextView,
    ) -> Result<NodeContext, ApiError> {
        self.api.get_node(node_id, view)
    }

    fn write_context(
        &self,
        node_id: NodeID,
        frame: Frame,
        agent_id: String,
    ) -> Result<FrameID, ApiError> {
        self.api.put_frame(node_id, frame, agent_id)
    }

    fn synthesize(
        &self,
        node_id: NodeID,
        frame_type: String,
        agent_id: String,
    ) -> Result<FrameID, ApiError> {
        self.api.synthesize_branch(node_id, frame_type, agent_id, None)
    }

    async fn generate_frame(
        &self,
        node_id: NodeID,
        _prompt: String, // Prompt is generated by queue from agent metadata
        frame_type: String,
        agent_id: String,
    ) -> Result<FrameID, ApiError> {
        // All generation MUST go through the queue
        let queue = self.queue.as_ref()
            .ok_or_else(|| ApiError::ConfigError(
                "Generation queue not available. All generation requests must go through the queue.".to_string()
            ))?;

        // Enqueue with Urgent priority and wait for completion (sync behavior)
        // Use a reasonable timeout (5 minutes)
        queue.enqueue_and_wait(
            node_id,
            agent_id,
            Some(frame_type),
            Priority::Urgent,
            Some(Duration::from_secs(300)),
        ).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::api::ContextApi;
    use crate::heads::HeadIndex;
    use crate::regeneration::BasisIndex;
    use crate::store::persistence::SledNodeRecordStore;
    use crate::types::Hash;
    use std::sync::Arc;
    use tempfile::TempDir;

    fn create_test_api() -> (ContextApi, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let store_path = temp_dir.path().join("store");
        let node_store = Arc::new(SledNodeRecordStore::new(&store_path).unwrap());
        let frame_storage_path = temp_dir.path().join("frames");
        std::fs::create_dir_all(&frame_storage_path).unwrap();
        let frame_storage = Arc::new(
            crate::frame::storage::FrameStorage::new(&frame_storage_path).unwrap()
        );
        let head_index = Arc::new(parking_lot::RwLock::new(HeadIndex::new()));
        let basis_index = Arc::new(parking_lot::RwLock::new(BasisIndex::new()));
        let agent_registry = Arc::new(parking_lot::RwLock::new(crate::agent::AgentRegistry::new()));
        let lock_manager = Arc::new(crate::concurrency::NodeLockManager::new());

        let api = ContextApi::new(
            node_store,
            frame_storage,
            head_index,
            basis_index,
            agent_registry,
            lock_manager,
        );

        (api, temp_dir)
    }

    #[test]
    fn test_adapter_creation() {
        let (api, _temp_dir) = create_test_api();
        let adapter = ContextApiAdapter::new(api);
        assert!(adapter.api().get_node(
            Hash::from([0u8; 32]),
            crate::api::ContextView {
                max_frames: 10,
                ordering: crate::views::OrderingPolicy::Recency,
                filters: vec![],
            }
        ).is_err()); // Should fail because node doesn't exist, but adapter works
    }
}
